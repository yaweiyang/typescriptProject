// 生活不易 且行且珍惜  By Yang
大话设计模式
第一章： 简单工厂模式 （Calculation.ts）
typescript (面向对象语言) 三大特性：封装、继承、多态
    UML类图： 1 、空心三角+实线 代表继承  2 、接口 矩形表示法、棒棒糖法 （interface）空心三角+虚线 代表实现接口  3 、 当一个类‘知道’另一类时，可以用关联（association） 箭头+实线
    4 、大雁和雁群 每一只大雁都属于一个雁群，一个雁群可以有多只大雁 ，可以用聚合（Aggergation） 聚合定义：表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象一部分 空心菱形+实线+箭头
    5 、大雁和翅膀 大雁和翅膀的关系是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样，被称作合成（Composition 也叫做组合）   实心菱形+实线+箭头
    6 、动物需要氧气、水、和食物等  动物和这些东西之间的关系是依赖（Dependency）关系  虚线+箭头

总结： 简单工厂模式 是把选择使用哪种算法、算法的实例化抽取出来放到工厂中  避免了客户端需要进行算法的实例化

第二章： 策略模式 (CashSystem.ts)
    收银系统  因为商场活动需要对商品进行不同的收费模式， 打折、满300返100、正常收费等收费模式。运用第一章学到的简单工厂模式，写出来一个收银系统。 但是不能满足商场经常对商品进行各种促销活动的需求，每一次都需要改动工厂 代码需要重新的编译部署，很明显是不合理的。  
    面对算法需要经常的改动这种情况，简单工厂模式就不怎么合适，策略模式很明显会是一个不错的选择。
    策略模式写出来的收银系统。使得选择不同算法的判断在客户端出现，这不应该。而简单工厂能够避免这种情况。
    简单工厂模式-策略模式结合，后把判断使用不同的算法这部分移动到Context类中。

总结： 策略模式 是把算法的统一调用放到Context类中 避免了客户端需要调用算法的接口
      简单工厂模式-策略模式 是把选择使用哪种算法、算法的实例化以及算法接口的调用抽取出来  避免客户端需要进行这部分的处理

第三章： 单一职责原则
    对一个类而言，应该有且仅有一个引起它变化的原因。
    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化，可能会削弱或者一直这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
    软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个职责。
第四章： 开放-封闭原则 ★
    开放-封闭原则是说软件实体（类、模块、函数等）应该可以扩展，但是不能修改。
    特征： 对于扩展是开放的； 对于更改是关闭的
    在开发过程中，面对不断改变的需求，我们需要保证已经实现的功能不会因为新功能的加入而出错，又要写入新的功能。 把之前的代码给推到全部重新编写很明显是我们不想选择的，因为花费重复的时间和精力做已经做过的事情。如果能够增加部分代码就能够完成新的需求，这才是最合理的。   所以代码的编写过程中需要遵循开放-封闭原则。
    面对需求，对程序的改动是通过增加新的代码进行的，而不是更改现有的代码。
    开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。
第五章： 依赖倒转原则、里氏代换原则 ★
    依赖倒转原则： 高层模块不应该依赖低层模块，两个都应该依赖抽象 ； 抽象不应该依赖细节。细节应该依赖抽象。
    里氏代换原则：子类型必须能够替换掉它们的父类型 
    正是由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展。

    以来倒转其实就是谁也不用依靠谁，除了约定好的接口，大家都可以灵活自如。
第六章： 装饰模式 (Decotate.ts)
    装饰模式（Decorator）：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活。
    装饰模式是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链中。
    装饰模式是为已有功能动态的添加更多功能的一种方式。当系统需要新的功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有的类的核心职责或主要行为。主类中加入新的字段、新的方法和新的逻辑，增加了主类的复杂度。
    装饰模式把类中的装饰功能从类中搬移去除，这样可以简化原有的类。有效的把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。
第七章: 代理模式 (AgentSystem.ts)
    代理模式（Proxy）: 为其他对象提供一种代理以控制这个对象的访问。
    创建一个接口，里面有被代理者的功能函数。创建两个类继承这个接口，被代理者正常实现自己的功能。代理者功能函数中调用的被代理者的功能函数。
第八章： 工厂方法模式
    简单工厂模式和工厂模式对比： 拿计算器举例，如果要增加新的计算方式。简单工厂模式，需要添加一个对应的计算类、然后在工厂类中添加case判断；工厂模式，需要添加对应计算类、对应工厂类以及客户端实例化工厂类的判断。
    工厂方法模式(Factory Mehod),定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。
第九章： 原型模式
    原型模式（Prototype）,用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    相当与创建一个模板，在现有基础上克隆一个出来，直接使用或者自己改动一下之后在去使用。
    深层拷贝  浅层拷贝
    浅复制： 被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。
    深复制： 把引用对象的变量指向要复制的新对象，而不是原有的被引用的对象。

    参考： https://blog.csdn.net/chentony123/article/details/81428803
第十章： 模板方法模式
    模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
第十一章： 迪米特法则
    迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的的某一个方法的话，可以通过第三者转发这个调用。
    强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。
第十二章： 外观模式
    外观模式： 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
第十三章：建造者模式
    建造者模式，将一个复杂对象的构建与它的表示分离，使得同样得构建过程可以创建不同得表示。

    